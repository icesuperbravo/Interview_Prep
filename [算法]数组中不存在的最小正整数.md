给定一个无序整型数组arr（数组中的数可能存在重复），找到数组中未出现的最小正整数。要求时间复杂度为O(N)，空间复杂度为O(1)。

例如：arr=[-1,2,3,4]；返回1。arr=[1,2,3,4]；返回5。arr=[1,2,3,4,1,-1]；返回5。

解题思路： 
1. 最先想到的是如果该数组为一个不重复的正整数有序数组，那么最小的正整数一定是遍历数组时第一个满足arr[i]!=i+1的数；
| arr_index     | 0 | 1 | 2 | 3 | 4 | 5 |
| ------------- |:-:|-:| -:|-:|-:|-:|
| arr_value     | 1 | 2 | 3 | 4 | 6 | 7 |

2. 数组的两种情况：

（1）  arr为整数1,2,3…N的一个随机排列，那个未出现的最小正整数就是N+1。

（2）  arr中有小于1或者大于N的数出现(我们称之为“不合法”的数)，则未出现的最小正整数一定在1到N中间（因为数组一共只有N个数，如果出现不合法的数，则出现的1到N之间的数的个数一定小于N，故一定有没有出现的数）。

3. 基于以上分析，具体实现过程如下：

（1）  先设置两个变量L,R。

L表示已经从1到L已经出现（左边界），L的初值为0。如果一个数字过大（不合法），就会被扔掉，用R表示这个右边界，即大于R的数会被扔掉。R的初值为N，表示从1到R的元素都不会被扔掉，大于R的就会被扔掉。但是这个R的值是变化的，如果L+1到R中有一个元素不合法，那么R--，因为最多只能放下R-1个合法数。

也就是说，1到L上的数已经出现，[L+1,R]区间上的数未出现但可能会出现。

（2）  从左开始遍历数组元素，遍历到L时，若arr[L]= L + 1,由于L表示前面已经出现的正整数，则说明1到L+1均出现，L++；若arr[L]<=L，R--；若arr[L]>R，arr[L] = arr[R-1],R--;

（3）  若arr[arr[L]-1]==arr[L]，说明有重复值，，arr[L] = arr[R-1],R--;

（4）  若以上情况均未发生，交换arr[L]与arr[arr[L]-1]，继续从L开始遍历。

（5）  最后L=R,返回L+1。


```javascript
var solution= function(arr)
{
  var l = 0; //left boundry
  var r = arr.length; //right boundry
  
  while (l<r)
  {
    if (arr[l]==l+1) l++;
    else if (arr[l]>r||arr[l]<=l||arr[l]==arr[arr[l]-1]) //如果arr[l]的值不在(l,r]这个范围之中，或者它的值在数组中有重复
      {
        r--;
        arr[l]=arr[r-1]; //将arr[l]的值从数组中去除，并将数组中最后一位的值移到index=l处
      } else //如果该值合法，只是位置不对
      {
        var temp=arr[l];
        arr[l]=arr[temp-1];
        arr[temp-1]=temp; //将arr[l]放置到正确的位置index=arr[l]-1, 然后将index=arr[l]-1的数交换到index=l处
      }
  }
  
  return l+1;
}
```
